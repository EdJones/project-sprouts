<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>File: daemon</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: daemon</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'>
<p>module Sprout</p>

<pre class="code"><span class='comment'>##
</span><span class='comment'># The Sprout::Daemon module exposes the Domain Specific Language
</span><span class='comment'># provided by the Sprout::Executable module, but with
</span><span class='comment'># enhancements (and modifications) to support long-lived processes
</span><span class='comment'># (like FDB and FCSH).
</span><span class='comment'>#
</span><span class='comment'># NOTE: Any class that includes Sprout::Daemon should first include 
</span><span class='comment'># Sprout::Executable. This is an admittedly smelly constraint, but it works
</span><span class='comment'># for now.
</span><span class='comment'>#
</span><span class='comment'>#   class Foo
</span><span class='comment'>#     include Sprout::Executable
</span><span class='comment'>#     include Sprout::Daemon
</span><span class='comment'>#
</span><span class='comment'>#     ##
</span><span class='comment'>#     # Keep in mind that we're still working
</span><span class='comment'>#     # with Executable, so add_param is available
</span><span class='comment'>#     # for the initialization of the process.
</span><span class='comment'>#     add_param :input, File
</span><span class='comment'>#
</span><span class='comment'>#     ##
</span><span class='comment'>#     # Expose the do_something action after
</span><span class='comment'>#     # the process is started.
</span><span class='comment'>#     add_action :do_something
</span><span class='comment'>#
</span><span class='comment'>#     ##
</span><span class='comment'>#     # Expose the do_something_else action after
</span><span class='comment'>#     # the process is started.
</span><span class='comment'>#     add_action :do_something_else
</span><span class='comment'>#   end
</span><span class='comment'>#
</span><span class='comment'># You can also create a globally-accessible rake task to expose
</span><span class='comment'># your new Daemon instance to Rake by creating a method like the following:
</span><span class='comment'>#
</span><span class='comment'>#   def foo *args, &amp;block
</span><span class='comment'>#     foo_tool = Foo.new
</span><span class='comment'>#     foo_tool.to_rake *args, &amp;block
</span><span class='comment'>#   end
</span><span class='comment'>#
</span><span class='comment'># Note: The aforementioned rake helper is usually written at the bottom of 
</span><span class='comment'># the class file that is referenced.
</span><span class='comment'># 
</span><span class='comment'># The aforementioned Rake task could be used like:
</span><span class='comment'>#
</span><span class='comment'>#   foo :bar do |t|
</span><span class='comment'>#     t.do_something
</span><span class='comment'>#     t.do_something_else
</span><span class='comment'>#   end
</span><span class='comment'>#
</span><span class='comment'># @see: Sprout::Daemon::ClassMethods
</span><span class='comment'># @see: Sprout::Daemon::InstanceMethods
</span><span class='comment'>#
</span><span class='kw'>module</span> <span class='const'>Daemon</span>

  <span class='id extend'>extend</span> <span class='const'>Concern</span>

  <span class='comment'>##
</span>  <span class='comment'># These are the methods that will be available
</span>  <span class='comment'># on any class that includes Sprout::Daemon.
</span>  <span class='kw'>module</span> <span class='const'>ClassMethods</span>

    <span class='comment'>##
</span>    <span class='comment'># Add an action that can be called while
</span>    <span class='comment'># the long-lived process is active.
</span>    <span class='comment'>#
</span>    <span class='comment'># This method should raise a Sprout::Errors::UsageError
</span>    <span class='comment'># if the provided action name is already defined for 
</span>    <span class='comment'># the provided instance.
</span>    <span class='kw'>def</span> <span class='id add_action'>add_action</span> <span class='id name'>name</span><span class='comma'>,</span> <span class='id arguments'>arguments</span><span class='op'>=</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id options'>options</span><span class='op'>=</span><span class='kw'>nil</span>
      <span class='id options'>options</span> <span class='op'>||=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span>
      <span class='id options'>options</span><span class='lbracket'>[</span><span class='symbol'>:name</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id name'>name</span>
      <span class='id options'>options</span><span class='lbracket'>[</span><span class='symbol'>:arguments</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id arguments'>arguments</span>
      <span class='id create_action_method'>create_action_method</span> <span class='id options'>options</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># Create an (often shorter) alias to another
</span>    <span class='comment'># action name.
</span>    <span class='kw'>def</span> <span class='id add_action_alias'>add_action_alias</span> <span class='id alias_name'>alias_name</span><span class='comma'>,</span> <span class='id source_name'>source_name</span>
      <span class='id define_method'>define_method</span><span class='lparen'>(</span><span class='id alias_name'>alias_name</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='op'>*</span><span class='id params'>params</span><span class='op'>|</span>
        <span class='kw'>self</span><span class='period'>.</span><span class='id send'>send</span><span class='lparen'>(</span><span class='id source_name'>source_name</span><span class='comma'>,</span> <span class='id params'>params</span><span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='id private'>private</span>

    <span class='comment'>##
</span>    <span class='comment'># Actually create the method for a provided
</span>    <span class='comment'># action.
</span>    <span class='comment'>#
</span>    <span class='comment'># This method should explode if the method name
</span>    <span class='comment'># already exists.
</span>    <span class='kw'>def</span> <span class='id create_action_method'>create_action_method</span> <span class='id options'>options</span>
      <span class='id name'>name</span> <span class='op'>=</span> <span class='id options'>options</span><span class='lbracket'>[</span><span class='symbol'>:name</span><span class='rbracket'>]</span>
      <span class='id accessor_can_be_defined_at'>accessor_can_be_defined_at</span> <span class='id name'>name</span>

      <span class='id define_method'>define_method</span><span class='lparen'>(</span><span class='id name'>name</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='op'>*</span><span class='id params'>params</span><span class='op'>|</span>
        <span class='id action'>action</span> <span class='op'>=</span> <span class='id name'>name</span><span class='period'>.</span><span class='id to_s'>to_s</span>
        <span class='id action'>action</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>y</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id name'>name</span> <span class='op'>==</span> <span class='symbol'>:confirm</span> <span class='comment'># Convert affirmation
</span>        <span class='id action'>action</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> </span><span class='embexpr_beg'>#{</span><span class='id params'>params</span><span class='period'>.</span><span class='id join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'> </span><span class='tstring_end'>'</span></span><span class='rparen'>)</span><span class='rbrace'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id params'>params</span><span class='period'>.</span><span class='id nil?'>nil?</span>
        <span class='id action_stack'>action_stack</span> <span class='op'>&lt;&lt;</span> <span class='id action'>action</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># TODO: Raise an exception if the name is 
</span>    <span class='comment'># already taken?
</span>    <span class='kw'>def</span> <span class='id accessor_can_be_defined_at'>accessor_can_be_defined_at</span> <span class='id name'>name</span>
    <span class='kw'>end</span>

  <span class='kw'>end</span>

  <span class='comment'>##
</span>  <span class='comment'># Instance methods that will be available on any
</span>  <span class='comment'># class that includes Sprout::Daemon.
</span>  <span class='kw'>module</span> <span class='const'>InstanceMethods</span>

    <span class='comment'>##
</span>    <span class='comment'># The prompt expression for this daemon process.
</span>    <span class='comment'>#
</span>    <span class='comment'># When executing a series of commands, the
</span>    <span class='comment'># wrapper will wait until it matches this expression
</span>    <span class='comment'># on stdout before continuing the series.
</span>    <span class='comment'>#
</span>    <span class='comment'># For FDB, this value is set like:
</span>    <span class='comment'>#
</span>    <span class='comment'>#   set :prompt, /^\(fdb\) /
</span>    <span class='comment'>#
</span>    <span class='comment'># Most processes can trigger a variety of different
</span>    <span class='comment'># prompts, these can be expressed here using the | (or) operator.
</span>    <span class='comment'>#
</span>    <span class='comment'># FDB actually uses the following:
</span>    <span class='comment'>#
</span>    <span class='comment'>#   set :prompt, /^\(fdb\) |\(y or n\) /
</span>    <span class='comment'>#
</span>    <span class='id attr_accessor'>attr_accessor</span> <span class='symbol'>:prompt</span>

    <span class='comment'>##
</span>    <span class='comment'># This is the array of actions that have
</span>    <span class='comment'># been provided at the class level to this instance.
</span>    <span class='id attr_reader'>attr_reader</span> <span class='symbol'>:action_stack</span>

    <span class='kw'>def</span> <span class='id initialize'>initialize</span>
      <span class='kw'>super</span>
      <span class='ivar'>@action_stack</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># Execute the Daemon executable, followed
</span>    <span class='comment'># by the collection of stored actions in 
</span>    <span class='comment'># the order they were called.
</span>    <span class='comment'>#
</span>    <span class='comment'># If none of the stored actions result in
</span>    <span class='comment'># terminating the process, the underlying
</span>    <span class='comment'># daemon will be connected to the terminal
</span>    <span class='comment'># for user (manual) input.
</span>    <span class='kw'>def</span> <span class='id execute'>execute</span>
      <span class='id runner'>runner</span> <span class='op'>=</span> <span class='kw'>super</span>
      <span class='id execute_actions'>execute_actions</span> <span class='id runner'>runner</span>
      <span class='id handle_user_session'>handle_user_session</span> <span class='id runner'>runner</span>
      <span class='const'>Process</span><span class='period'>.</span><span class='id wait'>wait</span> <span class='id runner'>runner</span><span class='period'>.</span><span class='id pid'>pid</span>
    <span class='kw'>end</span>

    <span class='id protected'>protected</span>

    <span class='comment'>##
</span>    <span class='comment'># This is the override of the underlying
</span>    <span class='comment'># Sprout::Executable template method so that we
</span>    <span class='comment'># create a 'task' instead of a 'file' task.
</span>    <span class='kw'>def</span> <span class='id create_outer_task'>create_outer_task</span> <span class='op'>*</span><span class='id args'>args</span>
      <span class='id task'>task</span> <span class='op'>*</span><span class='id args'>args</span> <span class='kw'>do</span>
        <span class='id execute'>execute</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># This is the override of the underlying
</span>    <span class='comment'># Sprout::Executable template method so that we
</span>    <span class='comment'># are NOT added to the CLEAN collection.
</span>    <span class='comment'># (Work performed in the Executable)
</span>    <span class='kw'>def</span> <span class='id update_rake_task_name_from_args'>update_rake_task_name_from_args</span> <span class='op'>*</span><span class='id args'>args</span>
      <span class='kw'>self</span><span class='period'>.</span><span class='id rake_task_name'>rake_task_name</span> <span class='op'>=</span> <span class='id parse_rake_task_arg'>parse_rake_task_arg</span> <span class='id args'>args</span><span class='period'>.</span><span class='id last'>last</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># This is the override of the underlying
</span>    <span class='comment'># Sprout::Executable template method so that we
</span>    <span class='comment'># create the process in a thread 
</span>    <span class='comment'># in order to read and write to it.
</span>    <span class='kw'>def</span> <span class='id system_execute'>system_execute</span> <span class='id binary'>binary</span><span class='comma'>,</span> <span class='id params'>params</span>
      <span class='const'>Sprout</span><span class='period'>.</span><span class='id current_system'>current_system</span><span class='period'>.</span><span class='id execute_thread'>execute_thread</span> <span class='id binary'>binary</span><span class='comma'>,</span> <span class='id params'>params</span>
    <span class='kw'>end</span>

    <span class='id private'>private</span>

    <span class='comment'>##
</span>    <span class='comment'># Execute the collection of provided actions.
</span>    <span class='kw'>def</span> <span class='id execute_actions'>execute_actions</span> <span class='id runner'>runner</span>
      <span class='id action_stack'>action_stack</span><span class='period'>.</span><span class='id each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id action'>action</span><span class='op'>|</span>
        <span class='kw'>if</span> <span class='id wait_for_prompt'>wait_for_prompt</span> <span class='id runner'>runner</span>
          <span class='const'>Sprout</span><span class='op'>::</span><span class='const'>Log</span><span class='period'>.</span><span class='id puts'>puts</span> <span class='id action'>action</span>
          <span class='id execute_action'>execute_action</span> <span class='id runner'>runner</span><span class='comma'>,</span> <span class='id action'>action</span>
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># Execute a single action.
</span>    <span class='kw'>def</span> <span class='id execute_action'>execute_action</span> <span class='id runner'>runner</span><span class='comma'>,</span> <span class='id action'>action</span>
      <span class='id runner'>runner</span><span class='period'>.</span><span class='id puts'>puts</span> <span class='id action'>action</span><span class='period'>.</span><span class='id strip'>strip</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># Expose the running process to manual
</span>    <span class='comment'># input on the terminal, and write stdout
</span>    <span class='comment'># back to the user.
</span>    <span class='kw'>def</span> <span class='id handle_user_session'>handle_user_session</span> <span class='id runner'>runner</span>
      <span class='kw'>while</span> <span class='op'>!</span><span class='id runner'>runner</span><span class='period'>.</span><span class='id r'>r</span><span class='period'>.</span><span class='id eof?'>eof?</span>
        <span class='kw'>if</span> <span class='id wait_for_prompt'>wait_for_prompt</span> <span class='id runner'>runner</span>
          <span class='id input'>input</span> <span class='op'>=</span> <span class='gvar'>$stdin</span><span class='period'>.</span><span class='id gets'>gets</span><span class='period'>.</span><span class='id chomp!'>chomp!</span>
          <span class='id execute_action'>execute_action</span> <span class='id runner'>runner</span><span class='comma'>,</span> <span class='id input'>input</span>
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='comment'>##
</span>    <span class='comment'># Wait for the underlying process to present
</span>    <span class='comment'># an input prompt, so that another action
</span>    <span class='comment'># can be submitted, or user input can be
</span>    <span class='comment'># collected.
</span>    <span class='kw'>def</span> <span class='id wait_for_prompt'>wait_for_prompt</span> <span class='id runner'>runner</span><span class='comma'>,</span> <span class='id expected_prompt'>expected_prompt</span><span class='op'>=</span><span class='kw'>nil</span>
      <span class='comment'>##
</span>      <span class='comment'># TODO: This should also check for a variety of prompts...
</span>      <span class='id expected_prompt'>expected_prompt</span> <span class='op'>=</span> <span class='id expected_prompt'>expected_prompt</span> <span class='op'>||</span> <span class='id prompt'>prompt</span>
      <span class='id line'>line</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_end'>'</span></span>

      <span class='kw'>while</span> <span class='id runner'>runner</span><span class='period'>.</span><span class='id alive?'>alive?</span> <span class='kw'>do</span>
        <span class='const'>Sprout</span><span class='op'>::</span><span class='const'>Log</span><span class='period'>.</span><span class='id flush'>flush</span>
        <span class='kw'>return</span> <span class='kw'>false</span> <span class='kw'>if</span> <span class='id runner'>runner</span><span class='period'>.</span><span class='id r'>r</span><span class='period'>.</span><span class='id eof?'>eof?</span>
        <span class='id char'>char</span> <span class='op'>=</span> <span class='id runner'>runner</span><span class='period'>.</span><span class='id readpartial'>readpartial</span> <span class='int'>1</span>
        <span class='id line'>line</span> <span class='op'>&lt;&lt;</span> <span class='id char'>char</span>
        <span class='kw'>if</span> <span class='id char'>char</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
          <span class='id line'>line</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_end'>'</span></span>
        <span class='kw'>end</span>
        <span class='const'>Sprout</span><span class='op'>::</span><span class='const'>Log</span><span class='period'>.</span><span class='id printf'>printf</span> <span class='id char'>char</span>
        <span class='kw'>return</span> <span class='kw'>true</span> <span class='kw'>if</span> <span class='id line'>line</span><span class='period'>.</span><span class='id match'>match</span> <span class='id expected_prompt'>expected_prompt</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

  <span class='kw'>end</span>
<span class='kw'>end</span></pre>

<p>end</p>
</div></div>
    
    <div id="footer">
  Generated on Tue Dec 21 11:09:49 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.3 (ruby-1.9.2).
</div>

  </body>
</html>